<link rel="import" href="../polymer/polymer-element.html" />

<link rel="import" href="../px-vis/px-vis-behavior-common.html" />
<link rel="import" href="../px-vis/px-vis-behavior-d3.html" />
<link rel="import" href="../px-vis/px-vis-behavior-chart.html" />
<link rel="import" href="../px-vis/px-vis-behavior-scale.html" />
<link rel="import" href="../px-vis/px-vis-svg.html" />
<link rel="import" href="../px-vis/px-vis-axis.html" />
<link rel="import" href="../px-vis/px-vis-gridlines.html" />
<link rel="import" href="../px-vis/px-vis-interaction-space.html" />
<link rel="import" href="../px-vis/px-vis-cursor.html" />
<link rel="import" href="../px-vis/px-vis-tooltip.html" />
<link rel="import" href="../px-vis/px-vis-register.html" />
<link rel="import" href="../px-vis/px-vis-threshold.html" />
<link rel="import" href="../px-vis/px-vis-clip-path.html" />
<link rel="import" href="../px-vis/px-vis-toolbar.html" />
<link rel="import" href="../px-vis/px-vis-annotations.html" />
<link rel="import" href="../px-vis/px-vis-bar-svg.html" />
<link rel="import" href="../px-vis/px-vis-bar-grouped-svg.html" />
<link rel="import" href="../px-vis/px-vis-reference-curve.html" />
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html" />
<link rel="import" href="../polymer/lib/utils/debounce.html">


<link rel="import" href="css/px-vis-bar-chart-styles.html" />

<!--
REPLACE THIS TEXT WITH A COMPONENT DESCRIPTION

No

### Usage

    <px-vis-bar-chart counter-value="1"></px-vis-bar-chart>

@element px-vis-bar-chart
@blurb REPLACE THIS TEXT WITH A COMPONENT DESCRIPTION
@homepage index.html
@demo index.html
-->

<dom-module id="px-vis-bar-chart">
  <template>
    <style include="px-vis-bar-chart-styles"></style>

    <div id="wrapper" class$="{{_chartWrapperClass}}" >
      <!--chart + register-->
      <div class$="{{_registerWrapperClass}} safari-flex-fix">
        <px-vis-register
          id="register"
          dynamic-menu-config="[[dynamicMenuConfig]]"
          chart-width="[[width]]"
          height="[[_verticalRegisterHeight]]"
          margin="[[margin]]"
          class$="{{_getHideClass(hideRegister)}}"
          units="[[units]]"
          tooltip-data="[[tooltipData]]"
          chart-data="[[chartData]]"
          complete-series-config="[[completeSeriesConfig]]"
          muted-series="{{mutedSeries}}"
          type="{{_registerType}}"
          x-axis-type="[[xAxisType]]"
          y-axis-type="[[yAxisType]]"
          inert-register="[[hideRegister]]"
          current-page="[[_registerCurrentPage]]"
          total-pages="[[_registerTotalPages]]"
          display-page-arrows="[[_registerDisplayPageArrows]]"
          reverse-display-order="[[_getRegisterDisplayOrder(yAxisType)]]">
        </px-vis-register>

        <!-- chart -->
        <div id="drawingWrapper" class="flex--col flex__item--no-grow inline--flex">
          <px-vis-toolbar
            id="toolbar"
            current-sub-config='[[toolbarSubConfig]]'
            action-config='{{actionConfig}}'
            within-chart
            chart-margin="[[margin]]"
            config='{"zoom": true, "pan": true, "tooltip": true}'>
          </px-vis-toolbar>
          <px-vis-svg
            id="svg"
            class="flex__item--no-grow"
            width="[[width]]"
            height="[[height]]"
            margin="[[margin]]"
            svg="{{svg}}"
            px-svg-elem="{{pxSvgElem}}">
              <px-vis-annotations
                slot="4"
                svg="[[svg]]"
                x="[[x]]"
                y="[[y]]"
                margin="[[margin]]"
                domain-changed="[[domainChanged]]"
                complete-series-config="[[completeSeriesConfig]]"
                annotation-data="[[annotationData]]"
                show-strong-icon="[[showStrongIcon]]">
              </px-vis-annotations>
          </px-vis-svg>
        </div>
      </div>
    </div>

    <px-vis-tooltip
      id="tooltip"
      orientation="[[_getTooltipOrientation(xAxisType)]]"
      hover-target=[[mouseRect]]
      mouse-position="[[mousePosition]]"
      width="250"
      margin="[[margin]]"
      chart-data="[[chartData]]"
      tooltip-data="[[tooltipData]]"
      complete-series-config="[[completeSeriesConfig]]"
      x-axis-type="[[xAxisType]]"
      y-axis-type="[[yAxisType]]"
      tooltip-style="light"
      muted-series="[[mutedSeries]]"
      hide="[[!_computedShowTooltip]]"
      series-keys="[[_seriesKeys]]">
    </px-vis-tooltip>

    <px-vis-clip-path
      svg="[[layer.2]]"
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]"
      clip-path="{{clipPath}}"
      series-clip-path="{{seriesClipPath}}">
    </px-vis-clip-path>

    <template is="dom-if" if="[[!grouped]]">
      <template is="dom-repeat" items="[[_stackedChartData]]">
        <px-vis-bar-svg
          id="bars"
          svg="[[layer.2]]"
          complete-series-config="[[completeSeriesConfig]]"
          chart-data="[[item]]"
          series-key="[[item.key]]"
          x="[[x]]"
          y="[[y]]"
          type="[[chartType]]"
          domain-changed="[[domainChanged]]"
          clip-path="[[seriesClipPath]]"
          highlight-bar="[[_getOrdSet(tooltipData.*)]]">
        </px-vis-bar-svg>
      </template>
    </template>

    <template is="dom-if" if="[[grouped]]">
      <px-vis-bar-grouped-svg
        id="bars"
        svg="[[layer.2]]"
        height="[[height]]"
        margin="[[margin]]"
        complete-series-config="[[completeSeriesConfig]]"
        chart-data="[[chartData]]"
        x="[[x]]"
        y="[[y]]"
        ordinal-key="[[_ordinalKey]]"
        group-scale="[[_groupScale]]"
        series-keys="[[_seriesKeys]]"
        type="[[chartType]]"
        domain-changed="[[domainChanged]]"
        clip-path="[[seriesClipPath]]"
        highlight-bar="[[_getOrdSet(tooltipData.*)]]">
      </px-vis-bar-grouped-svg>
    </template>

    <px-vis-threshold
      svg="[[layer.3]]"
      complete-series-config="[[completeSeriesConfig]]"
      threshold-data="[[thresholdData]]"
      threshold-config="[[thresholdConfig]]"
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]"
      x="[[x]]"
      y="[[y]]"
      domain-changed="[[domainChanged]]"
      clip-path="[[seriesClipPath]]"
      show-threshold-box="[[showThresholdBox]]"
      type="[[_getValueKey(xAxisType)]]"
      language="[[language]]">
    </px-vis-threshold>

    <px-vis-axis
      id="xAxis"
      svg="[[layer.1]]"
      domain-changed="[[domainChanged]]"
      axis="[[x]]"
      axis-type="[[xAxisType]]"
      margin="[[margin]]"
      width="[[width]]"
      height="[[height]]"
      orientation="[[xAxisLocation]]"
      label-position="after"
      complete-series-config="[[completeSeriesConfig]]"
      prevent-series-bar>
    </px-vis-axis>
    <px-vis-axis
      id="yAxis"
      svg="[[layer.1]]"
      domain-changed="[[domainChanged]]"
      axis="[[y]]"
      axis-type="[[yAxisType]]"
      margin="[[margin]]"
      width="[[width]]"
      height="[[height]]"
      orientation="[[yAxisLocation]]"
      label-position="after"
      complete-series-config="[[completeSeriesConfig]]"
      prevent-series-bar>
    </px-vis-axis>

    <template is="dom-if" if="[[_showGridlines(hideGridlines, chartType, 'bar')]]" restamp>
      <px-vis-gridlines
        svg="[[layer.0]]"
        axis="[[x]]"
        margin="[[margin]]"
        length="[[height]]"
        orientation="bottom"
        domain-changed="[[domainChanged]]">
      </px-vis-gridlines>
    </template>
    <template is="dom-if" if="[[_showGridlines(hideGridlines, chartType, 'column')]]" restamp>
      <px-vis-gridlines
        svg="[[layer.0]]"
        axis="[[y]]"
        margin="[[margin]]"
        length="[[width]]"
        orientation="left"
        domain-changed="[[domainChanged]]">
      </px-vis-gridlines>
    </template>

    <px-vis-interaction-space
      id="interactionSpace"
      svg="[[layer.4]]"
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]"
      x-axis-type="[[xAxisType]]"
      y-axis-type="[[yAxisType]]"
      series-keys="[[_seriesKeys]]"
      complete-series-config="[[completeSeriesConfig]]"
      chart-data="[[chartData]]"
      chart-id="[[chartId]]"
      x="[[x]]"
      y="[[y]]"
      domain-changed="[[domainChanged]]"
      mouse-rect="{{mouseRect}}"
      tooltip-data="{{tooltipData}}"
      crosshair-data="{{crosshairData}}"
      default-empty-data="[[defaultEmptyData]]"
      generating-crosshair-data="{{generatingCrosshairData}}"
      interaction-svg="{{interactionSvg}}"
      extents-data="{{extentsData}}"
      action-config="[[actionConfig]]"
      selection-type="[[selectionType]]"
      extents-action="{{extentsAction}}"
      muted-series="[[mutedSeries]]"
      hard-mute="[[hardMute]]"
      is-bar
      prevent-web-worker-synchronization="[[preventWebWorkerSynchronization]]"
      ww-data-sync-counter="[[wwDataSyncCounter]]">
    </px-vis-interaction-space>

    <px-vis-reference-curve
      id="referenceCurve"
      svg="[[layer.3]]"
      x="[[x]]"
      y="[[y]]"
      reverse-data="[[_isOrdinalType(yAxisType)]]"
      domain-changed="[[domainChanged]]"
      reference-config="[[referenceConfig]]"
      reference-data="[[referenceData]]"
      clip-path="[[seriesClipPath]]">
    </px-vis-reference-curve>

  </template>
  <script>
    const behaviours = [
      PxVisBehavior.observerCheck,
      PxVisBehavior.baseSize,
      PxVisBehavior.margins,
      PxVisBehavior.dataset,
      PxVisBehavior.completeSeriesConfig,
      PxVisBehavior.muteUnmuteSeries,
      PxVisBehavior.tooltipData,
      PxVisBehavior.extentsData,
      PxVisBehavior.commonMethods,
      PxVisBehavior.zoomSelection,
      PxVisBehavior.chartExtents,
      PxVisBehavior.dataExtents,
      PxVisBehaviorD3.svg,
      PxVisBehaviorD3.axes,
      PxVisBehaviorD3.clipPath,
      PxVisBehaviorChart.chartCommon,
      PxVisBehaviorChart.saveImage,
      PxVisBehaviorD3.domainUpdate,
      PxVisBehaviorChart.subConfiguration,
      PxVisBehaviorChart.registerConfigs,
      PxVisBehaviorChart.axisConfigs,
      PxVisBehaviorChart.registerPositioning,
      PxVisBehaviorChart.chartAutoResize,
      PxVisBehavior.thresholds,
      PxVisBehaviorChart.layers,
      PxVisBehavior.dynamicMenuConfig,
      PxColorsBehavior.dataVisColorTheming,
      PxVisBehavior.axisTypes,
      PxVisBehaviorScale.scale,
      PxVisBehavior.actionConfig,
      PxVisBehaviorChart.zooming,
      PxVisBehaviorChart.actionRequest,
      PxVisBehaviorChart.toolbarSubConfig,
      PxVisBehaviorChart.noDebounceOnPanning,
      PxVisBehaviorChart.chartToolbarConfig,
      PxVisBehaviorChart.showTooltip,
      PxVisBehaviorChart.sizeVerticalRegister,
      PxVisBehaviorChart.thresholdConfig,
      PxVisBehavior.selectionType,
      PxVisBehaviorChart.webWorkerSynchronization,
      // Polymer.AppLocalizeBehavior,
      PxVisBehavior.updateStylesOverride,
      PxVisBehavior.annotationData,
      PxVisBehaviorChart.tooltipSizing,
      PxVisBehavior.referenceCurveProps
    ];

    class PxVisBarChart extends Polymer.mixinBehaviors(behaviours, Polymer.Element) {
      static get is() { return 'px-vis-bar-chart'; }

      static get properties() {
        return {
          preventWebWorkerSynchronization: {
            type: Boolean,
            value: true,
            readOnly: true
          },
          /**
          * Specfies what type of bar chart:
          * - `bar`
          * - `horizontal`
          */
          chartType: {
            type: String,
            value: 'column'
          },

          _stackedChartData: {
            type: Array,
            computed: '_returnStack(chartData.*, _seriesKeys.*)'
          },

          /**
          * Defines where to locate the X-axis.
          * - `bottom`
          * - `top`
          *
          */
          xAxisLocation: {
            type:String,
            value:'bottom'
          },
          /**
          * Defines where to locate the Y-axis.
          * - `left`
          * - `right`
          *
          */
          yAxisLocation: {
            type: String,
            value:'left'
          },

          /**
          * DO NOT CHANGE THIS UNLESS YOU KNOW WHAT YOU ARE DOING
          *
          * Bar charts in nearly all cases should start from 0. If you have a special case and understand the ramifications, change this to false to allow it to use the `min` value from your data
          */
          startFromZero: {
            type: Boolean,
            value: true
          },

          _ordinalKey: {
            type: String,
            computed: '_getOrdKey(completeSeriesConfig.*)'
          },

          _stackedDataExtentsTrigger: {
            type: Number,
            value: 0
          },

          grouped: {
            type: Boolean,
            value: false
          },

          _baseline: Object

        };
      }

      static get observers() {
        return [
          '_setAxisTypes(chartType)',
          '_setXScale(width, margin, xAxisType)',
          '_setYScale(height, margin, yAxisType)',
          '_setDomain(_chartDataHasChanged, x, y, completeSeriesConfig, _stackedDataExtentsTrigger)',
          '_setDomain(chartExtents, _stackedDataExtentsTrigger)',
          '_chartDataChanged(chartData.*)',
          '_calcTooltipPos(tooltipData.*)',
          '_calcStackedDataExt(_stackedChartData, completeSeriesConfig, grouped)',
          '_createGroupScale(x,y, domainChanged, completeSeriesConfig, grouped)',
          '_drawBaseline(domainChanged)',

          '_xAxisConfigChanged(xAxisConfig.*)',
          '_yAxisConfigChanged(yAxisConfig.*)'

        ];
      }

      ready() {
        super.ready();
        this.set('numberOfLayers', 5);
        this.set('_verticalRegisterDrawingCanvasId', 'svg');
        this.addEventListener('iron-resize', this._onIronResize.bind(this));
      }

      connectedCallback() {
        super.connectedCallback();
      }

      _debounce(name, cb, time) {
        this[name] = Polymer.Debouncer.debounce(
          this[name],
          Polymer.Async.timeOut.after(time),
          cb.bind(this));
      }

      _onIronResize() {
        if(this.preventResize) {
          return;
        }

        this._debounce('ironresize', this._onIronResizeDebounced, this.debounceResizeTiming);
      }

      _onIronResizeDebounced() {
        //make sure we are not preventing resize in case it changed while debouncing
        if(this.preventResize) {
          return;
        }

        requestAnimationFrame(() => {
          var wrapperRect = this.$.wrapper.getBoundingClientRect(),
              registerRect = this.$.register.getBoundingClientRect(),
              toolbarRect = this.$.toolbar.getBoundingClientRect(),
              heightDeduct = 0,
              widthDeduct = 0;


          if(this.$.register.type === 'horizontal') {
            heightDeduct += registerRect.height;
          } else {
            widthDeduct += registerRect.width;
          }

          heightDeduct += toolbarRect.height;

          this.set('width', Math.max(wrapperRect.width - widthDeduct, 0));
          this.set('height', Math.max(wrapperRect.height - heightDeduct, 0));
          this._computeVerticalRegisterHeight([toolbarRect.height]);
        });
      }

      _returnStack() {
        if(this.grouped) {
          return [];
        }

        if(this.chartData && this._seriesKeys && this.completeSeriesConfig) {
          const axis = this.xAxisType === 'scaleBand' ? 'y' : 'x';
          const stack = Px.d3.stack();
          const keys = [];

          this._seriesKeys.forEach((k) => {
            keys.push(this.completeSeriesConfig[k][axis]);
          });

          stack.offset(Px.d3.stackOffsetDiverging);
          stack.keys(keys);
          return stack(this.chartData);
        }
      }

      _setAxisTypes(chartType) {
        switch(chartType) {
          case 'bar':
            this.set('xAxisType', "linear");
            this.set('yAxisType', "scaleBand");
            break;

          default:  //column
            this.set('xAxisType', "scaleBand");
            this.set('yAxisType', "linear");
            break;
        }
      }

      _getOrdKey() {
        if(this.hasUndefinedArguments(arguments)) {
          return;
        }

        if(this._seriesKeys && this._seriesKeys.length) {
          const k = this.xAxisType === 'scaleBand' ? 'x' : 'y';
          return this.completeSeriesConfig[this._seriesKeys[0]][k];
        } else {
          return '';
        }
      }

      _getRegisterDisplayOrder(yAxisType) {
        return yAxisType === 'scaleBand'
      }

      _showGridlines(hideGridlines, chartType, type) {
        if(chartType === type && !hideGridlines) {
          return true;
        }

        return false;
      }

      _calcTooltipPos() {
        if(this.showTooltip && this.tooltipData && this.tooltipData.series && this.tooltipData.series.length && this.tooltipData.series[0].coord) {
          if(!this._svgClientRect) {
            this._getImmediateSizing();
          }

          //calc the screen positions for the tooltip
          let screenX = this._svgClientRect.left + this._winX + this.margin.left;
          let screenY = this.margin.top + this._svgClientRect.top + this._winY;

          if(this.xAxisType === 'scaleBand') {
            screenX += this.x.bandwidth()/2 + this.tooltipData.series[0]['coord'][0];
            screenY += this.grouped ?
                        this._getLargestCoord(1, 'min') :
                        this.y(this._getSummedVal('x'));

          } else {
            screenY += this.y.bandwidth()/2 + this.tooltipData.series[0]['coord'][1];
            screenX += this.grouped ?
                        this._getLargestCoord(0, 'max') :
                        this.x(this._getSummedVal('y'));

          }

          this.set('mousePosition', [screenX, screenY]);
        }
      }

      _getLargestCoord(index, type) {
        return Px.d3[type](this.tooltipData.series, (d) => { return d.coord[index]; });
      }

      _getSummedVal(axis) {
        const index = Px.d3.bisectLeft(this[axis].domain(), this.tooltipData.ordinalSet);

        return Px.d3.max(this._stackedChartData, (d) => { return d[index][1] });
      }

      _getOrdSet() {
        if(this.tooltipData && this.tooltipData.ordinalSet) {
          return this.tooltipData.ordinalSet;
        }

        return '';
      }

      _calcStackedDataExt() {
        if(this.grouped) {
          this.set('_stackedDataExtentsTrigger', this._stackedDataExtentsTrigger += 1);
        }

        if(this.completeSeriesConfig && this._doesObjHaveValues(this._stackedChartData)) {
          const min = Px.d3.min(this._stackedChartData, (dataset) => {
            return Px.d3.min(dataset, (d) => { return Math.min(d[0],d[1]); });
          });
          const max = Px.d3.max(this._stackedChartData, (dataset) => {
            return Px.d3.max(dataset, (d) => { return d[1]; });
          });

          if(this.xAxisType === 'scaleBand') {
            this.dataExtents = {
              "x": this.dataExtents.x,
              "y": [min,max]
            };
          } else {
            this.dataExtents = {
              "x": [min,max],
              "y": this.dataExtents.y
            };
          }

          this.set('_stackedDataExtentsTrigger', this._stackedDataExtentsTrigger += 1);
        }
      }

      _createGroupScale() {
        if(!this.grouped || !this.x || !this.y || !this.completeSeriesConfig || this.domainChanged === null) {
          return;
        }

        const ordScale = this.xAxisType === 'scaleBand' ? 'x' : 'y';
        const valScale = this._getValueKey();
        const keys = [];

        this._seriesKeys.forEach((k) => {
          keys.push(this.completeSeriesConfig[k][valScale]);
        });

        const scale = Px.d3.scaleBand()
          .padding(0.05)
          .rangeRound([0, this[ordScale].bandwidth()])
          .domain(keys);

        this.set('_groupScale', scale);
      }

      _drawBaseline() {
        const valScale = this._getValueKey();

        if(this[valScale].domain()[0] < 0) {
          let x1, x2,
              y1, y2;

          if(this.xAxisType === 'scaleBand') {
            x1 = this.x.range()[0];
            x2 = this.x.range()[1];
            y1 = this.y(0);
            y2 = this.y(0);

          } else {
            x1 = this.x(0);
            x2 = this.x(0);
            y1 = this.y.range()[0];
            y2 = this.y.range()[1];

          }

          if(!this._baseline) {
            this._baseline = this.layer[3]
              .append('line')
          }

          this._baseline
            .attr('x1', x1)
            .attr('x2', x2)
            .attr('y1', y1)
            .attr('y2', y2)
            .attr('stroke', this._checkThemeVariable("--px-vis-axis-color", 'black'));

        } else {
          if(this._baseline) {
            if(this._baseline.remove) {
              this._baseline.remove();
            }
            this._baseline = null;
          }
        }
      }

      _getValueKey() {
        return this.xAxisType === 'scaleBand' ? 'y' : 'x'
      }

      _xAxisConfigChanged(conf) {
        if(this.hasUndefinedArguments(arguments)) {
          return;
        }

        this._applyConfigToElement(this.xAxisConfig, this.$.xAxis);
      }

      _yAxisConfigChanged(conf) {
        if(this.hasUndefinedArguments(arguments)) {
          return;
        }

        this._applyConfigToElement(this.yAxisConfig, this.$.yAxis);
      }

      _getTooltipOrientation(xAxisType) {
        return xAxisType === 'scaleBand' ? 'top' : 'right';
      }

    }

    window.customElements.define(PxVisBarChart.is, PxVisBarChart);
  </script>
</dom-module>