<link rel="import" href="../polymer/polymer-element.html"/>
<link rel="import" href="../polymer/lib/elements/dom-repeat.html"/>
<link rel="import" href="../polymer/lib/elements/dom-if.html"/>
<link rel="import" href="../polymer/lib/utils/async.html"/>

<link rel="import" href="../px-vis/px-vis-behavior-common.html"/>
<link rel="import" href="../px-vis/px-vis-behavior-d3.html"/>
<link rel="import" href="../px-vis/px-vis-behavior-chart.html"/>
<link rel="import" href="../px-vis/px-vis-behavior-scale.html"/>
<link rel="import" href="../px-vis/px-vis-svg.html"/>
<link rel="import" href="../px-vis/px-vis-axis.html"/>
<link rel="import" href="../px-vis/px-vis-gridlines.html"/>
<link rel="import" href="../px-vis/px-vis-interaction-space.html"/>
<link rel="import" href="../px-vis/px-vis-cursor.html"/>
<link rel="import" href="../px-vis/px-vis-tooltip.html"/>
<link rel="import" href="../px-vis/px-vis-register.html"/>
<link rel="import" href="../px-vis/px-vis-threshold.html"/>
<link rel="import" href="../px-vis/px-vis-clip-path.html"/>
<link rel="import" href="../px-vis/px-vis-toolbar.html"/>
<link rel="import" href="../px-vis/px-vis-annotations.html"/>
<link rel="import" href="../px-vis/px-vis-bar-svg.html"/>
<link rel="import" href="../px-vis/px-vis-bar-grouped-svg.html"/>
<link rel="import" href="../px-vis/px-vis-reference-curve.html"/>
<link rel="import" href="../px-vis/px-vis-line-svg.html"/>
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html"/>

<link rel="import" href="css/px-vis-bar-chart-styles.html"/>

<!--
Creates an interactive bar chart, column chart, stacked bar, stacked column, grouped bar, grouped column, deviation bar, and deviation column

### Usage

    <px-vis-bar-chart
      width="1200"
      height="500"
      scale-padding="0.1"
      margin='{
        "left": 130,
        "right": 130,
        "top": 10,
        "bottom": 50
      }'
      chart-data="[[chartData]]"
      series-config="[[seriesConfig]]">
    </px-vis-bar-chart>

### Styling
The following custom properties are available for styling:

Custom property | Description
----------------|-------------
  `--px-vis-axis-color` | The color for the axis lines, axis ticks, and axis tick labels
  `--px-vis-axis-title-color` | The color for the axis title
  |
  |
  |
  `--px-vis-gridlines-color` | The color for the gridlines
  |
  |
  |
  `--px-vis-threshold-color` | The default color for a threshold
  |
  |
  |
  `--px-vis-reference-curve-default-color` | default color for the reference curve
  |
  |
  |
  `--px-vis-register-series-name` | The color of the data series name
  `--px-vis-register-data-value` | The color of the data series value
  `--px-vis-register-box` | The color of the box around the register when a scrollbar is present
  |
  |
  |
  `--px-vis-series-color-0` | These are the colors used to represent the data series on the charts. Used in numerical order by default. Colors MUST start at 0 and cannot contain gaps between numbers.
  `--px-vis-series-color-1` |
  `--px-vis-series-color-2` |
  `--px-vis-series-color-n` |
  |
  |
  |
  `--px-tooltip-background-color` | The color of the tooltip
  `--px-tooltip-text-color` | The color of the tooltip text
  `--px-tooltip-light-background-color` | The color of the light version tooltip
  `--px-tooltip-light-text-color` | The color of the light version tooltip text
  `--px-tooltip-light-border-color`| The color of the light version tooltip border
  |
  |
  |
  `--px-vis-font-family` | The font family for all labels and text

@element px-vis-bar-chart
@blurb Creates an interactive bar chart
@homepage index.html
@demo index.html
-->

<dom-module id="px-vis-bar-chart">
  <template>
    <style include="px-vis-bar-chart-styles"></style>

    <div id="wrapper" class$="{{_chartWrapperClass}}" >
      <!--chart + register-->
      <div class$="{{_registerWrapperClass}} safari-flex-fix">
        <px-vis-register
          id="register"
          dynamic-menu-config="[[dynamicMenuConfig]]"
          chart-width="[[width]]"
          height="[[_verticalRegisterHeight]]"
          margin="[[margin]]"
          class$="{{_getHideClass(hideRegister)}}"
          units="[[units]]"
          tooltip-data="[[tooltipData]]"
          chart-data="[[chartData]]"
          complete-series-config="[[completeSeriesConfig]]"
          muted-series="{{mutedSeries}}"
          type="{{_registerType}}"
          x-axis-type="[[xAxisType]]"
          y-axis-type="[[yAxisType]]"
          inert-register="[[hideRegister]]"
          current-page="[[_registerCurrentPage]]"
          total-pages="[[_registerTotalPages]]"
          display-page-arrows="[[_registerDisplayPageArrows]]"
          display-x-values-only="[[_getRegisterDisplay(yAxisType)]]"
          display-y-values-only="[[_getRegisterDisplay(xAxisType)]]"
          display-ordinal-value
          disable-click
          icon-color="[[_registerIconColor]]">
        </px-vis-register>

        <!-- chart -->
        <div id="drawingWrapper" class="flex--col flex__item--no-grow inline--flex">
          <px-vis-toolbar
            id="toolbar"
            current-sub-config='[[toolbarSubConfig]]'
            action-config='{{actionConfig}}'
            within-chart
            chart-margin="[[margin]]"
            config='{"tooltip": true}'>
          </px-vis-toolbar>
          <px-vis-svg
            id="svg"
            class="flex__item--no-grow"
            width="[[width]]"
            height="[[height]]"
            margin="[[margin]]"
            svg="{{svg}}"
            px-svg-elem="{{pxSvgElem}}">
              <px-vis-annotations
                slot="4"
                svg="[[svg]]"
                x="[[x]]"
                y="[[y]]"
                margin="[[margin]]"
                domain-changed="[[domainChanged]]"
                complete-series-config="[[completeSeriesConfig]]"
                annotation-data="[[annotationData]]"
                show-strong-icon="[[showStrongIcon]]">
              </px-vis-annotations>
          </px-vis-svg>
        </div>
      </div>
    </div>

    <px-vis-tooltip
      id="tooltip"
      orientation="[[_getTooltipOrientation(xAxisType)]]"
      hover-target=[[mouseRect]]
      mouse-position="[[mousePosition]]"
      width="250"
      margin="[[margin]]"
      chart-data="[[chartData]]"
      tooltip-data="[[tooltipData]]"
      complete-series-config="[[completeSeriesConfig]]"
      x-axis-type="[[xAxisType]]"
      y-axis-type="[[yAxisType]]"
      tooltip-style="light"
      muted-series="[[mutedSeries]]"
      hide="[[!_computedShowTooltip]]"
      series-keys="[[_seriesKeys]]"
      display-x-values-only="[[_getRegisterDisplay(yAxisType)]]"
      display-y-values-only="[[_getRegisterDisplay(xAxisType)]]"
      display-ordinal-value
      icon-color="[[_registerIconColor]]">
    </px-vis-tooltip>

    <px-vis-clip-path
      svg="[[layer.2]]"
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]"
      clip-path="{{clipPath}}"
      series-clip-path="{{seriesClipPath}}">
    </px-vis-clip-path>

    <template is="dom-if" if="[[!grouped]]" restamp>
      <template is="dom-repeat" items="[[_stackedChartData]]">
        <px-vis-bar-svg
          id="bars"
          svg="[[layer.2]]"
          complete-series-config="[[completeSeriesConfig]]"
          chart-data="[[item]]"
          series-key="[[item.key]]"
          x="[[x]]"
          y="[[y]]"
          type="[[chartType]]"
          domain-changed="[[domainChanged]]"
          clip-path="[[seriesClipPath]]"
          highlight-bar="[[_getOrdSet(tooltipData.*)]]">
        </px-vis-bar-svg>
      </template>
    </template>

    <template is="dom-if" if="[[grouped]]" restamp>
      <px-vis-bar-grouped-svg
        id="bars"
        svg="[[layer.2]]"
        height="[[height]]"
        margin="[[margin]]"
        complete-series-config="[[completeSeriesConfig]]"
        chart-data="[[chartData]]"
        x="[[x]]"
        y="[[y]]"
        ordinal-key="[[_ordinalKey]]"
        group-scale="[[_groupScale]]"
        series-keys="[[_groupKeys]]"
        type="[[chartType]]"
        domain-changed="[[domainChanged]]"
        clip-path="[[seriesClipPath]]"
        highlight-bar="[[_getOrdSet(tooltipData.*)]]"
        color-by-group="[[colorByGroup]]"
        group-colors="[[_groupColors]]">
      </px-vis-bar-grouped-svg>
    </template>
    <!--
      When the time comes to make this multi-y which will happen, we shouldnt make it multi-y using the methods for timeseries / xy. Instead, we should just create a second y axis, cloned from the first and then modified. This can then be applied to the line and only the line. We should never allow bars to be multi-axis.
     -->
    <template id="lineTemplate" is="dom-repeat" items="[[_seriesKeys]]">
      <template is="dom-if" if="[[_chartTypeLine(item,completeSeriesConfig)]]" restamp>
        <px-vis-line-svg
          id="lineSVG"
          svg="[[_lineG]]"
          series-id="[[item]]"
          chart-data="[[chartData]]"
          complete-series-config="[[completeSeriesConfig]]"
          domain-changed="[[domainChanged]]"
          x="[[x]]"
          y="[[y]]"
          clip-path="[[seriesClipPath]]"
          stroke-width="[[_returnStrokeWidth(item, completeSeriesConfig)]]"
          interpolation-function="[[interpolationFunction]]"
          serie-to-redraw-on-top="[[serieToRedrawOnTop]]">
        </px-vis-line-svg>
      </template>
    </template>

    <px-vis-threshold
      svg="[[layer.3]]"
      complete-series-config="[[completeSeriesConfig]]"
      threshold-data="[[thresholdData]]"
      threshold-config="[[thresholdConfig]]"
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]"
      x="[[x]]"
      y="[[y]]"
      domain-changed="[[domainChanged]]"
      clip-path="[[seriesClipPath]]"
      show-threshold-box="[[showThresholdBox]]"
      language="[[language]]">
    </px-vis-threshold>

    <px-vis-axis
      id="xAxis"
      svg="[[layer.1]]"
      rebuild-on-draw
      domain-changed="[[domainChanged]]"
      axis="[[x]]"
      axis-type="[[xAxisType]]"
      margin="[[margin]]"
      width="[[width]]"
      height="[[height]]"
      orientation="[[xAxisLocation]]"
      label-position="after"
      complete-series-config="[[completeSeriesConfig]]"
      prevent-series-bar>
    </px-vis-axis>
    <px-vis-axis
      id="yAxis"
      svg="[[layer.1]]"
      rebuild-on-draw
      domain-changed="[[domainChanged]]"
      axis="[[y]]"
      axis-type="[[yAxisType]]"
      margin="[[margin]]"
      width="[[width]]"
      height="[[height]]"
      orientation="[[yAxisLocation]]"
      complete-series-config="[[completeSeriesConfig]]"
      prevent-series-bar>
    </px-vis-axis>

    <template is="dom-if" if="[[_showGridlines(hideGridlines, chartType, 'bar')]]" restamp>
      <px-vis-gridlines
        svg="[[layer.0]]"
        axis="[[x]]"
        margin="[[margin]]"
        length="[[height]]"
        orientation="bottom"
        domain-changed="[[domainChanged]]">
      </px-vis-gridlines>
    </template>
    <template is="dom-if" if="[[_showGridlines(hideGridlines, chartType, 'column')]]" restamp>
      <px-vis-gridlines
        svg="[[layer.0]]"
        axis="[[y]]"
        margin="[[margin]]"
        length="[[width]]"
        orientation="left"
        domain-changed="[[domainChanged]]">
      </px-vis-gridlines>
    </template>

    <px-vis-interaction-space
      id="interactionSpace"
      svg="[[layer.4]]"
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]"
      x-axis-type="[[xAxisType]]"
      y-axis-type="[[yAxisType]]"
      series-keys="[[_seriesKeys]]"
      complete-series-config="[[completeSeriesConfig]]"
      chart-data="[[chartData]]"
      chart-id="[[chartId]]"
      x="[[x]]"
      y="[[y]]"
      domain-changed="[[domainChanged]]"
      mouse-rect="{{mouseRect}}"
      tooltip-data="{{tooltipData}}"
      crosshair-data="{{crosshairData}}"
      default-empty-data="[[defaultEmptyData]]"
      generating-crosshair-data="{{generatingCrosshairData}}"
      interaction-svg="{{interactionSvg}}"
      extents-data="{{extentsData}}"
      action-config="[[actionConfig]]"
      selection-type="[[selectionType]]"
      extents-action="{{extentsAction}}"
      muted-series="[[mutedSeries]]"
      hard-mute="[[hardMute]]"
      is-bar
      prevent-web-worker-synchronization="[[preventWebWorkerSynchronization]]"
      ww-data-sync-counter="[[wwDataSyncCounter]]">
    </px-vis-interaction-space>

    <px-vis-reference-curve
      id="referenceCurve"
      chart-id="[[chartId]]"
      svg="[[_lineG]]"
      x="[[x]]"
      y="[[y]]"
      reverse-data="[[_isOrdinalType(yAxisType)]]"
      domain-changed="[[domainChanged]]"
      reference-config="[[referenceConfig]]"
      reference-data="[[referenceData]]"
      clip-path="[[seriesClipPath]]">
    </px-vis-reference-curve>

    <template is="dom-if" if="[[_hasLines]]" restamp>
      <px-vis-cursor
        id="cursor"
        svg="[[_lineG]]"
        width="[[width]]"
        height="[[height]]"
        margin="[[margin]]"
        complete-series-config="[[_cursorSeriesConfig]]"
        chart-data="[[chartData]]"
        tooltip-data="[[tooltipData]]"
        clip-path="[[seriesClipPath]]"
        series-keys="[[_seriesKeys]]"
        horizontal-line="none"
        vertical-line="none">
      </px-vis-cursor>
    </template>
  </template>
  <script>
  (() => {
    const behaviours = [
      PxVisBehavior.observerCheck,
      PxVisBehavior.baseSize,
      PxVisBehavior.margins,
      PxVisBehavior.dataset,
      PxVisBehavior.completeSeriesConfig,
      PxVisBehavior.muteUnmuteSeries,
      PxVisBehavior.tooltipData,
      PxVisBehavior.extentsData,
      PxVisBehavior.commonMethods,
      PxVisBehavior.zoomSelection,
      PxVisBehavior.chartExtents,
      PxVisBehavior.dataExtents,
      PxVisBehaviorD3.svg,
      PxVisBehaviorD3.axes,
      PxVisBehaviorD3.clipPath,
      PxVisBehaviorChart.chartCommon,
      PxVisBehaviorChart.saveImage,
      PxVisBehaviorD3.domainUpdate,
      PxVisBehaviorChart.subConfiguration,
      PxVisBehaviorChart.registerConfigs,
      PxVisBehaviorChart.axisConfigs,
      PxVisBehaviorChart.registerPositioning,
      PxVisBehaviorChart.chartAutoResize,
      PxVisBehavior.thresholds,
      PxVisBehaviorChart.layers,
      PxVisBehavior.dynamicMenuConfig,
      PxColorsBehavior.dataVisColorTheming,
      PxVisBehavior.axisTypes,
      PxVisBehaviorScale.scale,
      PxVisBehavior.actionConfig,
      PxVisBehaviorChart.zooming,
      PxVisBehaviorChart.actionRequest,
      PxVisBehaviorChart.toolbarSubConfig,
      PxVisBehaviorChart.noDebounceOnPanning,
      PxVisBehaviorChart.chartToolbarConfig,
      PxVisBehaviorChart.showTooltip,
      PxVisBehaviorChart.sizeVerticalRegister,
      PxVisBehaviorChart.thresholdConfig,
      PxVisBehavior.selectionType,
      PxVisBehaviorChart.webWorkerSynchronization,
      Polymer.AppLocalizeBehavior,
      PxVisBehavior.updateStylesOverride,
      PxVisBehavior.annotationData,
      PxVisBehaviorChart.tooltipSizing,
      PxVisBehavior.referenceCurveProps
    ];

    /**
    *
    * @polymer
    * @customElement
    * @appliesMixin PxVisBehavior.observerCheck
    * @appliesMixin PxVisBehavior.baseSize
    * @appliesMixin PxVisBehavior.margins
    * @appliesMixin PxVisBehavior.dataset
    * @appliesMixin PxVisBehavior.completeSeriesConfig
    * @appliesMixin PxVisBehavior.muteUnmuteSeries
    * @appliesMixin PxVisBehavior.tooltipData
    * @appliesMixin PxVisBehavior.extentsData
    * @appliesMixin PxVisBehavior.commonMethods
    * @appliesMixin PxVisBehavior.zoomSelection
    * @appliesMixin PxVisBehavior.chartExtents
    * @appliesMixin PxVisBehavior.dataExtents
    * @appliesMixin PxVisBehaviorD3.svg
    * @appliesMixin PxVisBehaviorD3.axes
    * @appliesMixin PxVisBehaviorD3.clipPath
    * @appliesMixin PxVisBehaviorChart.chartCommon
    * @appliesMixin PxVisBehaviorChart.saveImage
    * @appliesMixin PxVisBehaviorD3.domainUpdate
    * @appliesMixin PxVisBehaviorChart.subConfiguration
    * @appliesMixin PxVisBehaviorChart.registerConfigs
    * @appliesMixin PxVisBehaviorChart.axisConfigs
    * @appliesMixin PxVisBehaviorChart.registerPositioning
    * @appliesMixin PxVisBehaviorChart.chartAutoResize
    * @appliesMixin PxVisBehavior.thresholds
    * @appliesMixin PxVisBehaviorChart.layers
    * @appliesMixin PxVisBehavior.dynamicMenuConfig
    * @appliesMixin PxColorsBehavior.dataVisColorTheming
    * @appliesMixin PxVisBehavior.axisTypes
    * @appliesMixin PxVisBehaviorScale.scale
    * @appliesMixin PxVisBehavior.actionConfig
    * @appliesMixin PxVisBehaviorChart.zooming
    * @appliesMixin PxVisBehaviorChart.actionRequest
    * @appliesMixin PxVisBehaviorChart.toolbarSubConfig
    * @appliesMixin PxVisBehaviorChart.noDebounceOnPanning
    * @appliesMixin PxVisBehaviorChart.chartToolbarConfig
    * @appliesMixin PxVisBehaviorChart.showTooltip
    * @appliesMixin PxVisBehaviorChart.sizeVerticalRegister
    * @appliesMixin PxVisBehaviorChart.thresholdConfig
    * @appliesMixin PxVisBehavior.selectionType
    * @appliesMixin PxVisBehaviorChart.webWorkerSynchronization
    * @appliesMixin PxVisBehavior.updateStylesOverride
    * @appliesMixin PxVisBehavior.annotationData
    * @appliesMixin PxVisBehaviorChart.tooltipSizing
    * @appliesMixin PxVisBehavior.referenceCurveProps
    */
    class PxVisBarChart extends Polymer.mixinBehaviors(behaviours, Polymer.Element) {
      static get is() { return 'px-vis-bar-chart'; }

      static get properties() {
        return {
          preventWebWorkerSynchronization: {
            type: Boolean,
            value: true,
            readOnly: true
          },
          /**
          * A default configuration file. It fills in the missing parts of seriesConfig. Any options from seriesConfig can be specified in the defaultSeriesConfig and will be automatically used if not defined in the seriesConfig
          *
          * Default:
          *
          * ```
          *  {
          *     "type": "bar",
          *     "x": "x",
          *     "y": "y"
          *   }
          * ```
          */
          _defaultSeriesConfig: {
            type: Object,
            value: function() {
              return {
                x: "x",
                y: "y",
                type: "bar"
              }
            }
          },
          /**
          * Specfies what type of bar chart:
          * - `bar`
          * - `column`
          */
          chartType: {
            type: String,
            value: 'column'
          },

          _stackedChartData: {
            type: Array
          },

          /**
          * Defines where to locate the X-axis.
          * - `bottom`
          * - `top`
          *
          */
          xAxisLocation: {
            type:String,
            value:'bottom'
          },
          /**
          * Defines where to locate the Y-axis.
          * - `left`
          * - `right`
          *
          */
          yAxisLocation: {
            type: String,
            value:'left'
          },

          /**
          * DO NOT CHANGE THIS UNLESS YOU KNOW WHAT YOU ARE DOING
          *
          * Bar charts in nearly all cases should start from 0. If you have a special case and understand the ramifications, change this to false to allow it to use the `min` value from your data
          */
          startFromZero: {
            type: Boolean,
            value: true
          },

          _ordinalKey: {
            type: String,
            computed: '_getOrdKey(completeSeriesConfig.*)'
          },

          _stackedDataExtentsTrigger: {
            type: Number,
            value: 0
          },
          /**
           * Create a grouped bar chart.
           *
           * Default is to create a stacked bar chart
           * */
          grouped: {
            type: Boolean,
            value: false
          },

          /**
           * Color each group one color rather than a series across groups having the same color
           *
           * */
          colorByGroup: {
            type: Boolean,
            value: false
          },
          /**
           * An object associating group colors to your groups
           *
           * ```
           * {
           *   group1: "rgb(255,0,0)",
           *   group2: "rgb(0,255,0)",
           *   group3: "rgb(0,0,255)",
           * }
           * ```
           *
           * */
          groupColors: Object,
          _groupColors: Object,
          _registerIconColor: String,
          _lineG: Object,
          _baseline: Object,
          _groupKeys: Object,
          _cursorSeriesConfig: Object,
          _hasLines: {
            type: Boolean,
            value: false
          }

        };
      }

      static get observers() {
        return [
          '_returnStack(chartData.*, completeSeriesConfig.*)',
          '_setAxisTypes(chartType)',
          '_groupChanged(grouped)',
          '_setGroupColors(grouped,colorByGroup,domainChanged)',
          '_setXScale(width, margin, xAxisType)',
          '_setYScale(height, margin, yAxisType)',
          '_setDomain(_chartDataHasChanged, x, y, completeSeriesConfig, _stackedDataExtentsTrigger)',
          '_setDomain(chartExtents, _stackedDataExtentsTrigger)',
          '_updatePadding(scalePadding)',
          '_chartDataChanged(chartData.*)',
          '_calcTooltipPos(tooltipData.*)',
          '_getRegisterIconColor(tooltipData.*)',
          '_calcStackedDataExt(_stackedChartData, completeSeriesConfig, grouped)',
          '_createGroupScale(x,y, domainChanged, completeSeriesConfig, _seriesKeys, grouped)',
          '_createLineGroup(layers, domainChanged)',
          '_drawBaseline(domainChanged)',
          '_checkReference(referenceData.*)',

          '_xAxisConfigChanged(xAxisConfig.*)',
          '_yAxisConfigChanged(yAxisConfig.*)'
        ];
      }

      constructor() {
        super();
        this.__debouncers = {};
      }

      connectedCallback() {
        super.connectedCallback();
        this.set('numberOfLayers', 5);
        this.set('_verticalRegisterDrawingCanvasId', 'svg');
        this.set('_verticalRegisterHeightDeductions', ['toolbar']);
      }

      ready() {
        super.ready();
        this.addEventListener('iron-resize', this._onIronResize.bind(this));
        this.$.referenceCurve.addEventListener('reference-changed', this._checkReference.bind(this));
        if(this.referenceConfig) {
          this._checkReference();
        }
      }

      _debounce(name, cb, time) {
        this.__debouncers[name] = Polymer.Debouncer.debounce(
          this.__debouncers[name],
          Polymer.Async.timeOut.after(time),
          cb.bind(this));
      }

      _onIronResize() {
        if(this.preventResize) {
          return;
        }

        this._debounce('ironresize', this._onIronResizeDebounced, this.debounceResizeTiming);
      }

      _onIronResizeDebounced() {
        //make sure we are not preventing resize in case it changed while debouncing
        if(this.preventResize) {
          return;
        }

        requestAnimationFrame(() => {
          var wrapperRect = this.$.wrapper.getBoundingClientRect(),
              registerRect = this.$.register.getBoundingClientRect(),
              toolbarRect = this.$.toolbar.getBoundingClientRect(),
              heightDeduct = 0,
              widthDeduct = 0;


          if(this.$.register.type === 'horizontal') {
            heightDeduct += registerRect.height;
          } else {
            widthDeduct += registerRect.width;
          }

          heightDeduct += toolbarRect.height;

          this.set('width', Math.max(wrapperRect.width - widthDeduct, 0));
          this.set('height', Math.max(wrapperRect.height - heightDeduct, 0));
          this._computeVerticalRegisterHeight([toolbarRect.height]);
        });
      }

      _returnStack() {
        if(this.grouped) {
          this.set('_stackedChartData', []);
          return;
        }

        if(!this.chartData ||
            !this.completeSeriesConfig) {
          return;
        }

        const axis = this.xAxisType === 'scaleBand' ? 'y' : 'x';
        const stack = Px.d3.stack();
        const barKeys = [];
        let hasLines = false;
        const cursorSeries = {};

        // could use Object.values but there doesnt appear to be an official
        // shim for IE yet and value of shiming it vs just using entries ¯\_(ツ)_/¯
        for(let [k,v] of Object.entries(this.completeSeriesConfig)) {
          if(v.type === 'bar') {
            barKeys.push(v[axis]);
          } else if(v.type === 'line') {
            hasLines = true;
            cursorSeries[k] = v;
          }
        }

        stack.offset(Px.d3.stackOffsetDiverging);
        stack.keys(barKeys);
        this.set('_stackedChartData', stack(this.chartData));
        this.set('_hasLines', hasLines);
        this.set('_cursorSeriesConfig', cursorSeries);
      }

      _setAxisTypes(chartType) {
        if(this.domainChanged) {
          this.setProperties({
            domainChanged: 0,
            x: null,
            y: null,
            dataExtents: null
          });

        }

        if(chartType === 'bar') {
          this.setProperties({
            'xAxisType': "linear",
            'yAxisType': "scaleBand"
          });
        } else { //column
          this.setProperties({
            'xAxisType': "scaleBand",
            'yAxisType': "linear"
          });
        }

        this._setCompleteSeriesConfig();
      }

      _groupChanged() {
        this._setCompleteSeriesConfig();
      }

      _setGroupColors() {
        if(this.grouped && this.colorByGroup) {
          this._dontCalcColors = true;
          if(this.groupColors) {
            this.set('_groupColors', this.groupColors);
            return;
          }

          if(this.domainChanged) {
            const groups = this.x.domain();
            const colors = {};

            groups.forEach((group, i) => {
              colors[group] = this.seriesColorList[i];
            });

            this.set('_groupColors', colors);
          }
        } else {
          this._dontCalcColors = false;
        }
      }

      _getOrdKey() {
        if(this.hasUndefinedArguments(arguments)) {
          return;
        }

        if(this._seriesKeys && this._seriesKeys.length) {
          const k = this.xAxisType === 'scaleBand' ? 'x' : 'y';
          return this.completeSeriesConfig[this._seriesKeys[0]][k];
        } else {
          return '';
        }
      }

      _getRegisterDisplay(axisType) {
        return axisType === 'scaleBand'
      }

      _showGridlines(hideGridlines, chartType, type) {
        if(chartType === type && !hideGridlines) {
          return true;
        }

        return false;
      }

      _calcTooltipPos() {
        if(this.showTooltip && this.tooltipData && this.tooltipData.series && this.tooltipData.series.length && this.tooltipData.series[0].coord) {
          if(!this._svgClientRect) {
            this._getImmediateSizing();
          }

          //calc the screen positions for the tooltip
          let screenX = this._svgClientRect.left + this._winX + this.margin.left;
          let screenY = this.margin.top + this._svgClientRect.top + this._winY;

          if(this.xAxisType === 'scaleBand') {
            screenX += this.x.bandwidth()/2 + this.tooltipData.series[0]['coord'][0];
            screenY += this.grouped ?
                        this._getLargestCoord(1, 'min') :
                        this.y(this._getSummedVal('x'));

          } else {
            screenY += this.y.bandwidth()/2 + this.tooltipData.series[0]['coord'][1];
            screenX += this.grouped ?
                        this._getLargestCoord(0, 'max') :
                        this.x(this._getSummedVal('y'));

          }

          this.set('mousePosition', [screenX, screenY]);
        }
      }

      _getRegisterIconColor() {
        if(this.grouped && this.colorByGroup) {
          const set = this._getOrdSet();

          if(set) {
            this.set('_registerIconColor', this._groupColors[set]);
          } else {
            this.set('_registerIconColor', undefined);
          }
        }
      }

      _getLargestCoord(index, type) {
        return Px.d3[type](this.tooltipData.series, (d) => { return d.coord[index]; });
      }

      _getSummedVal(axis) {
        const index = Px.d3.bisectLeft(this[axis].domain(), this.tooltipData.ordinalSet);

        return Px.d3.max(this._stackedChartData, (d) => { return Math.max(d[index][0],d[index][1]); });
      }

      _getOrdSet() {
        if(this.tooltipData && this.tooltipData.ordinalSet) {
          return this.tooltipData.ordinalSet;
        }

        return '';
      }

      _calcStackedDataExt() {
        if(this.grouped) {
          this.set('_stackedDataExtentsTrigger', this._stackedDataExtentsTrigger += 1);
          return;
        }

        if(this.completeSeriesConfig && this._doesObjHaveValues(this._stackedChartData)) {
          // find the stacked values (which are generally bigger than raw chartData)
          const min = Px.d3.min(this._stackedChartData, (dataset) => {
            return Px.d3.min(dataset, (d) => { return Math.min(d[0],d[1]); });
          });
          const max = Px.d3.max(this._stackedChartData, (dataset) => {
            return Px.d3.max(dataset, (d) => { return d[1]; });
          });

          const exts = [min, max];
          const valScale = this._getValueKey();

          // now check our line series to see if they are bigger/smaller than stacks
          for(let [k,val] of Object.entries(this.completeSeriesConfig)) {
            if(val.type === 'line') {
              const ext = Px.d3.extent(this.chartData, (d) => {
                return d[val[valScale]];
              });

              exts[0] = Math.min(ext[0],exts[0]);
              exts[1] = Math.max(ext[1],exts[1]);
            }
          }

          if(this.xAxisType === 'scaleBand') {
            this.dataExtents = {
              "x": this.dataExtents.x,
              "y": exts
            };
          } else {
            this.dataExtents = {
              "x": exts,
              "y": this.dataExtents.y
            };
          }

          this.set('_stackedDataExtentsTrigger', this._stackedDataExtentsTrigger += 1);
        }
      }

      _createGroupScale() {
        if(!this.grouped ||
            !this.x ||
            !this.y ||
            !this.completeSeriesConfig ||
            this._seriesKeys.length === 0 ||
            !this.domainChanged) {
          return;
        }

        const ordScale = this.xAxisType === 'scaleBand' ? 'x' : 'y';
        const valScale = this._getValueKey();
        const domain = [];
        const keys = [];
        let hasLines = false;
        const cursorSeries = {};

        for(let [k,v] of Object.entries(this.completeSeriesConfig)) {
          if(v.type === 'bar') {
            domain.push(v[valScale]);
            keys.push(k);
          } else if(v.type === 'line') {
            hasLines = true;
            cursorSeries[k] = v;
          }
        };

        const scale = Px.d3.scaleBand()
          .padding(0.05)
          .rangeRound([0, this[ordScale].bandwidth()])
          .domain(domain);

        this.set('_groupKeys', keys);
        this.set('_groupScale', scale);
        this.set('_hasLines', hasLines);
        this.set('_cursorSeriesConfig', cursorSeries);
      }

      _createLineGroup() {
        if(!this.layer || this._isD3Empty(this.layer[3]) || !this.domainChanged) {
          return;
        }

        var g;

        if(this._isD3Empty(this._lineG)) {
          g = this.layer[3].append('g')
            .attr('class', 'lines');

          this.set('_lineG', g);
        }

        if(this._isOrdinalType(this.x._scaleType)) {
          this._lineG.attr('transform', 'translate(' + this.x.bandwidth()/2 + ',0)');

        } else if(this._isOrdinalType(this.y._scaleType)) {
          this._lineG.attr('transform', 'translate(0,' + this.y.bandwidth()/2 + ')');
        }

      }

      _drawBaseline() {
        if(!this.domainChanged) {
          return;
        }

        const valScale = this._getValueKey();

        if(this[valScale].domain()[0] < 0) {
          let x1, x2,
              y1, y2;

          if(this.xAxisType === 'scaleBand') {
            x1 = this.x.range()[0];
            x2 = this.x.range()[1];
            y1 = this.y(0);
            y2 = this.y(0);

          } else {
            x1 = this.x(0);
            x2 = this.x(0);
            y1 = this.y.range()[0];
            y2 = this.y.range()[1];

          }

          if(!this._baseline) {
            this._baseline = this.layer[3]
              .append('line')
          }

          this._baseline
            .attr('x1', x1)
            .attr('x2', x2)
            .attr('y1', y1)
            .attr('y2', y2)
            .attr('stroke', this._checkThemeVariable("--px-vis-axis-color", 'black'));

        } else {
          if(this._baseline) {
            if(this._baseline.remove) {
              this._baseline.remove();
            }
            this._baseline = null;
          }
        }
      }

      _getValueKey() {
        return this.xAxisType === 'scaleBand' ? 'y' : 'x'
      }

      _xAxisConfigChanged(conf) {
        if(this.hasUndefinedArguments(arguments)) {
          return;
        }

        this._applyConfigToElement(this.xAxisConfig, this.$.xAxis);
      }

      _yAxisConfigChanged(conf) {
        if(this.hasUndefinedArguments(arguments)) {
          return;
        }

        this._applyConfigToElement(this.yAxisConfig, this.$.yAxis);
      }

      _getTooltipOrientation(xAxisType) {
        return xAxisType === 'scaleBand' ? 'top' : 'right';
      }

      _checkReference() {
        this._debounce('_checkReference', () => {

          if(!this.referenceData || !this.$.referenceCurve._referenceConfig) {
            return;
          }

          for(let [k,v] of Object.entries(this.$.referenceCurve._referenceConfig)) {
            let search = true,
                i = 0;

            while(search) {
              let xInvalid = true,
                  yInvalid = true;

              if(this._isValidData(this.referenceData[i][v.x]) && this._isValidData(this.x(this.referenceData[i][v.x]))) {
                xInvalid = false;
              }
              if(this._isValidData(this.referenceData[i][v.y]) && this._isValidData(this.y(this.referenceData[i][v.y]))) {
                yInvalid = false;
              }

              search = xInvalid || yInvalid;
              i += 1;

              if(i === this.referenceData.length) {
                console.warn('Something is wrong with your referenceConfig / referenceData. Did you flip the x and y?');
                search = false;
              }
            }
          }
        }, 10);
      }
    }

    window.customElements.define(PxVisBarChart.is, PxVisBarChart);
    window.PxVisBarChart = PxVisBarChart;
  })();

  </script>
</dom-module>
