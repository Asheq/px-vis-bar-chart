<link rel="import" href="../polymer/polymer-element.html"/>
<link rel="import" href="../polymer/lib/elements/dom-repeat.html"/>
<link rel="import" href="../polymer/lib/elements/dom-if.html"/>
<link rel="import" href="../polymer/lib/utils/async.html"/>
<link rel="import" href="../polymer/lib/utils/import-href.html"/>

<link rel="import" href="../px-vis/px-vis-behavior-common.html"/>
<link rel="import" href="../px-vis/px-vis-behavior-d3.html"/>
<link rel="import" href="../px-vis/px-vis-behavior-chart.html"/>
<link rel="import" href="../px-vis/px-vis-behavior-scale.html"/>
<link rel="import" href="../px-vis/px-vis-svg.html"/>
<link rel="import" href="../px-vis/px-vis-axis.html"/>
<link rel="import" href="../px-vis/px-vis-gridlines.html"/>
<link rel="import" href="../px-vis/px-vis-interaction-space.html"/>
<link rel="import" href="../px-vis/px-vis-register.html"/>
<link rel="import" href="../px-vis/px-vis-clip-path.html"/>
<link rel="import" href="../px-vis/px-vis-toolbar.html"/>
<link rel="import" href="../px-vis/px-vis-annotations.html"/>
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html"/>

<link rel="import" href="css/px-vis-bar-chart-styles.html"/>

<!--
Creates an interactive bar chart, column chart, stacked bar, stacked column, grouped bar, grouped column, deviation bar, and deviation column

### Usage

    <px-vis-bar-chart
      width="1200"
      height="500"
      scale-padding="0.1"
      margin='{
        "left": 130,
        "right": 130,
        "top": 10,
        "bottom": 50
      }'
      chart-data="[[chartData]]"
      series-config="[[seriesConfig]]">
    </px-vis-bar-chart>

### Styling
The following custom properties are available for styling:

Custom property | Description
----------------|-------------
  `--px-vis-axis-color` | The color for the axis lines, axis ticks, and axis tick labels
  `--px-vis-axis-title-color` | The color for the axis title
  |
  |
  |
  `--px-vis-gridlines-color` | The color for the gridlines
  |
  |
  |
  `--px-vis-threshold-color` | The default color for a threshold
  |
  |
  |
  `--px-vis-reference-curve-default-color` | default color for the reference curve
  |
  |
  |
  `--px-vis-register-series-name` | The color of the data series name
  `--px-vis-register-data-value` | The color of the data series value
  `--px-vis-register-box` | The color of the box around the register when a scrollbar is present
  |
  |
  |
  `--px-vis-series-color-0` | These are the colors used to represent the data series on the charts. Used in numerical order by default. Colors MUST start at 0 and cannot contain gaps between numbers.
  `--px-vis-series-color-1` |
  `--px-vis-series-color-2` |
  `--px-vis-series-color-n` |
  |
  |
  |
  `--px-tooltip-background-color` | The color of the tooltip
  `--px-tooltip-text-color` | The color of the tooltip text
  `--px-tooltip-light-background-color` | The color of the light version tooltip
  `--px-tooltip-light-text-color` | The color of the light version tooltip text
  `--px-tooltip-light-border-color`| The color of the light version tooltip border
  |
  |
  |
  `--px-vis-font-family` | The font family for all labels and text

@element px-vis-bar-chart
@blurb Creates an interactive bar chart
@homepage index.html
@demo index.html
-->

<dom-module id="px-vis-bar-chart">
  <script>
  (() => {
    const behaviours = [
      PxVisBehavior.observerCheck,
      PxVisBehavior.baseSize,
      PxVisBehavior.margins,
      PxVisBehavior.dataset,
      PxVisBehavior.completeSeriesConfig,
      PxVisBehavior.muteUnmuteSeries,
      PxVisBehavior.tooltipData,
      PxVisBehavior.extentsData,
      PxVisBehavior.commonMethods,
      PxVisBehavior.zoomSelection,
      PxVisBehavior.chartExtents,
      PxVisBehavior.dataExtents,
      PxVisBehaviorD3.svg,
      PxVisBehaviorD3.axes,
      PxVisBehaviorD3.clipPath,
      PxVisBehaviorChart.chartCommon,
      PxVisBehaviorChart.saveImage,
      PxVisBehaviorD3.domainUpdate,
      PxVisBehaviorChart.subConfiguration,
      PxVisBehaviorChart.registerConfigs,
      PxVisBehaviorChart.axisConfigs,
      PxVisBehaviorChart.registerPositioning,
      PxVisBehaviorChart.chartAutoResize,
      PxVisBehavior.thresholds,
      PxVisBehaviorChart.layers,
      PxVisBehavior.dynamicMenuConfig,
      PxColorsBehavior.dataVisColorTheming,
      PxVisBehavior.axisTypes,
      PxVisBehaviorScale.scale,
      PxVisBehavior.actionConfig,
      PxVisBehaviorChart.zooming,
      PxVisBehaviorChart.actionRequest,
      PxVisBehaviorChart.toolbarSubConfig,
      PxVisBehaviorChart.noDebounceOnPanning,
      PxVisBehaviorChart.chartToolbarConfig,
      PxVisBehaviorChart.showTooltip,
      PxVisBehaviorChart.sizeVerticalRegister,
      PxVisBehaviorChart.thresholdConfig,
      PxVisBehavior.selectionType,
      PxVisBehaviorChart.webWorkerSynchronization,
      Polymer.AppLocalizeBehavior,
      PxVisBehavior.updateStylesOverride,
      PxVisBehavior.annotationData,
      PxVisBehaviorChart.tooltipSizing,
      PxVisBehavior.referenceCurveProps
    ];

    /**
    *
    * @polymer
    * @customElement
    * @appliesMixin PxVisBehavior.observerCheck
    * @appliesMixin PxVisBehavior.baseSize
    * @appliesMixin PxVisBehavior.margins
    * @appliesMixin PxVisBehavior.dataset
    * @appliesMixin PxVisBehavior.completeSeriesConfig
    * @appliesMixin PxVisBehavior.muteUnmuteSeries
    * @appliesMixin PxVisBehavior.tooltipData
    * @appliesMixin PxVisBehavior.extentsData
    * @appliesMixin PxVisBehavior.commonMethods
    * @appliesMixin PxVisBehavior.zoomSelection
    * @appliesMixin PxVisBehavior.chartExtents
    * @appliesMixin PxVisBehavior.dataExtents
    * @appliesMixin PxVisBehaviorD3.svg
    * @appliesMixin PxVisBehaviorD3.axes
    * @appliesMixin PxVisBehaviorD3.clipPath
    * @appliesMixin PxVisBehaviorChart.chartCommon
    * @appliesMixin PxVisBehaviorChart.saveImage
    * @appliesMixin PxVisBehaviorD3.domainUpdate
    * @appliesMixin PxVisBehaviorChart.subConfiguration
    * @appliesMixin PxVisBehaviorChart.registerConfigs
    * @appliesMixin PxVisBehaviorChart.axisConfigs
    * @appliesMixin PxVisBehaviorChart.registerPositioning
    * @appliesMixin PxVisBehaviorChart.chartAutoResize
    * @appliesMixin PxVisBehavior.thresholds
    * @appliesMixin PxVisBehaviorChart.layers
    * @appliesMixin PxVisBehavior.dynamicMenuConfig
    * @appliesMixin PxColorsBehavior.dataVisColorTheming
    * @appliesMixin PxVisBehavior.axisTypes
    * @appliesMixin PxVisBehaviorScale.scale
    * @appliesMixin PxVisBehavior.actionConfig
    * @appliesMixin PxVisBehaviorChart.zooming
    * @appliesMixin PxVisBehaviorChart.actionRequest
    * @appliesMixin PxVisBehaviorChart.toolbarSubConfig
    * @appliesMixin PxVisBehaviorChart.noDebounceOnPanning
    * @appliesMixin PxVisBehaviorChart.chartToolbarConfig
    * @appliesMixin PxVisBehaviorChart.showTooltip
    * @appliesMixin PxVisBehaviorChart.sizeVerticalRegister
    * @appliesMixin PxVisBehaviorChart.thresholdConfig
    * @appliesMixin PxVisBehavior.selectionType
    * @appliesMixin PxVisBehaviorChart.webWorkerSynchronization
    * @appliesMixin PxVisBehavior.updateStylesOverride
    * @appliesMixin PxVisBehavior.annotationData
    * @appliesMixin PxVisBehaviorChart.tooltipSizing
    * @appliesMixin PxVisBehavior.referenceCurveProps
    */
    class PxVisBarChart extends Polymer.mixinBehaviors(behaviours, Polymer.Element) {
      static get is() { return 'px-vis-bar-chart'; }

      static get template() {
        return Polymer.html`
          <style include="px-vis-bar-chart-styles"></style>

          <div id="wrapper" class$="{{_chartWrapperClass}}" >
            <!--chart + register-->
            <div class$="{{_registerWrapperClass}} safari-flex-fix">
              <px-vis-register
                id="register"
                dynamic-menu-config="[[dynamicMenuConfig]]"
                chart-width="[[width]]"
                height="[[_verticalRegisterHeight]]"
                margin="[[margin]]"
                class$="{{_getHideClass(hideRegister)}}"
                units="[[units]]"
                tooltip-data="[[tooltipData]]"
                chart-data="[[chartData]]"
                complete-series-config="[[completeSeriesConfig]]"
                muted-series="{{mutedSeries}}"
                type="{{_registerType}}"
                x-axis-type="[[xAxisType]]"
                y-axis-type="[[yAxisType]]"
                inert-register="[[hideRegister]]"
                current-page="[[_registerCurrentPage]]"
                total-pages="[[_registerTotalPages]]"
                display-page-arrows="[[_registerDisplayPageArrows]]"
                display-x-values-only="[[_getRegisterDisplay(yAxisType)]]"
                display-y-values-only="[[_getRegisterDisplay(xAxisType)]]"
                display-ordinal-value
                disable-click
                icon-color="[[_registerIconColor]]">
              </px-vis-register>

              <!-- chart -->
              <div id="drawingWrapper" class="flex--col flex__item--no-grow inline--flex">
                <px-vis-toolbar
                  id="toolbar"
                  current-sub-config='[[toolbarSubConfig]]'
                  action-config='{{actionConfig}}'
                  within-chart
                  chart-margin="[[margin]]"
                  config='{"tooltip": true}'>
                </px-vis-toolbar>
                <px-vis-svg
                  id="svg"
                  class="flex__item--no-grow"
                  width="[[width]]"
                  height="[[height]]"
                  margin="[[margin]]"
                  svg="{{svg}}"
                  px-svg-elem="{{pxSvgElem}}">
                    <px-vis-annotations
                      slot="4"
                      svg="[[svg]]"
                      x="[[x]]"
                      y="[[y]]"
                      margin="[[margin]]"
                      domain-changed="[[domainChanged]]"
                      complete-series-config="[[completeSeriesConfig]]"
                      annotation-data="[[annotationData]]"
                      show-strong-icon="[[showStrongIcon]]">
                    </px-vis-annotations>
                </px-vis-svg>
              </div>
            </div>
          </div>

          <px-vis-clip-path
            svg="[[layer.2]]"
            width="[[width]]"
            height="[[height]]"
            margin="[[margin]]"
            clip-path="{{clipPath}}"
            series-clip-path="{{seriesClipPath}}">
          </px-vis-clip-path>

          <px-vis-axis
            id="xAxis"
            svg="[[layer.1]]"
            rebuild-on-draw
            domain-changed="[[domainChanged]]"
            axis="[[x]]"
            axis-type="[[xAxisType]]"
            margin="[[margin]]"
            width="[[width]]"
            height="[[height]]"
            orientation="[[xAxisLocation]]"
            label-position="after"
            complete-series-config="[[completeSeriesConfig]]"
            prevent-series-bar>
          </px-vis-axis>
          <px-vis-axis
            id="yAxis"
            svg="[[layer.1]]"
            rebuild-on-draw
            domain-changed="[[domainChanged]]"
            axis="[[y]]"
            axis-type="[[yAxisType]]"
            margin="[[margin]]"
            width="[[width]]"
            height="[[height]]"
            orientation="[[yAxisLocation]]"
            complete-series-config="[[completeSeriesConfig]]"
            prevent-series-bar>
          </px-vis-axis>

          <template is="dom-if" if="[[_showGridlines(hideGridlines, chartType, 'bar')]]" restamp>
            <px-vis-gridlines
              svg="[[layer.0]]"
              axis="[[x]]"
              margin="[[margin]]"
              length="[[height]]"
              orientation="bottom"
              domain-changed="[[domainChanged]]">
            </px-vis-gridlines>
          </template>
          <template is="dom-if" if="[[_showGridlines(hideGridlines, chartType, 'column')]]" restamp>
            <px-vis-gridlines
              svg="[[layer.0]]"
              axis="[[y]]"
              margin="[[margin]]"
              length="[[width]]"
              orientation="left"
              domain-changed="[[domainChanged]]">
            </px-vis-gridlines>
          </template>

          <px-vis-interaction-space
            id="interactionSpace"
            svg="[[layer.4]]"
            width="[[width]]"
            height="[[height]]"
            margin="[[margin]]"
            x-axis-type="[[xAxisType]]"
            y-axis-type="[[yAxisType]]"
            series-keys="[[_seriesKeys]]"
            complete-series-config="[[completeSeriesConfig]]"
            chart-data="[[chartData]]"
            chart-id="[[chartId]]"
            x="[[x]]"
            y="[[y]]"
            domain-changed="[[domainChanged]]"
            mouse-rect="{{mouseRect}}"
            tooltip-data="{{tooltipData}}"
            crosshair-data="{{crosshairData}}"
            default-empty-data="[[defaultEmptyData]]"
            generating-crosshair-data="{{generatingCrosshairData}}"
            interaction-svg="{{interactionSvg}}"
            extents-data="{{extentsData}}"
            action-config="[[actionConfig]]"
            selection-type="[[selectionType]]"
            extents-action="{{extentsAction}}"
            muted-series="[[mutedSeries]]"
            hard-mute="[[hardMute]]"
            is-bar
            prevent-web-worker-synchronization="[[preventWebWorkerSynchronization]]"
            ww-data-sync-counter="[[wwDataSyncCounter]]">
          </px-vis-interaction-space>

          ${this.stackedBarTemplate}

          ${this.groupedBarTemplate}

          ${this.lineTemplate}

          ${this.thresholdsTemplate}

          ${this.referenceCurveTemplate}

          ${this.tooltipTemplate}

          ${this.extendBarChartTemplate}
        `;
      }


      static get stackedBarTemplate() {
        return Polymer.html`
          <template is="dom-if" if="[[!grouped]]" restamp>
            <template is="dom-repeat" items="[[_stackedChartData]]">
              <px-vis-bar-svg
                id="bars"
                svg="[[layer.2]]"
                complete-series-config="[[completeSeriesConfig]]"
                chart-data="[[item]]"
                series-key="[[item.key]]"
                x="[[x]]"
                y="[[y]]"
                type="[[chartType]]"
                domain-changed="[[domainChanged]]"
                clip-path="[[seriesClipPath]]"
                highlight-bar="[[_getOrdSet(tooltipData.*)]]">
              </px-vis-bar-svg>
            </template>
          </template>
        `;
      }

      static get groupedBarTemplate() {
        return Polymer.html`
          <template is="dom-if" if="[[grouped]]" restamp>
            <px-vis-bar-grouped-svg
              id="bars"
              svg="[[layer.2]]"
              height="[[height]]"
              margin="[[margin]]"
              complete-series-config="[[completeSeriesConfig]]"
              chart-data="[[chartData]]"
              x="[[x]]"
              y="[[y]]"
              ordinal-key="[[_ordinalKey]]"
              group-scale="[[_groupScale]]"
              series-keys="[[_groupKeys]]"
              type="[[chartType]]"
              domain-changed="[[domainChanged]]"
              clip-path="[[seriesClipPath]]"
              highlight-bar="[[_getOrdSet(tooltipData.*)]]"
              color-by-group="[[colorByGroup]]"
              group-colors="[[_groupColors]]">
            </px-vis-bar-grouped-svg>
          </template>
        `;
      }

      static get lineTemplate() {
        return Polymer.html`
          <template is="dom-if" if="[[_hasLines]]" restamp>
            <!--
            When the time comes to make this multi-y which will happen, we shouldnt make it multi-y using the methods for timeseries / xy. Instead, we should just create a second y axis, cloned from the first and then modified. This can then be applied to the line and only the line. We should never allow bars to be multi-axis.
              -->
            <template id="lineTemplate" is="dom-repeat" items="[[_returnLineSeriesKeys(_lineSeriesConfig.*)]]">
              <px-vis-line-svg
                id="lineSVG"
                svg="[[_lineG]]"
                series-id="[[item]]"
                chart-data="[[chartData]]"
                complete-series-config="[[completeSeriesConfig]]"
                domain-changed="[[domainChanged]]"
                x="[[x]]"
                y="[[y]]"
                clip-path="[[seriesClipPath]]"
                stroke-width="[[_returnStrokeWidth(item, completeSeriesConfig)]]"
                interpolation-function="[[interpolationFunction]]"
                serie-to-redraw-on-top="[[serieToRedrawOnTop]]">
              </px-vis-line-svg>
            </template>

            <px-vis-cursor
              id="cursor"
              svg="[[_lineG]]"
              width="[[width]]"
              height="[[height]]"
              margin="[[margin]]"
              complete-series-config="[[_lineSeriesConfig]]"
              chart-data="[[chartData]]"
              tooltip-data="[[tooltipData]]"
              clip-path="[[seriesClipPath]]"
              series-keys="[[_seriesKeys]]"
              horizontal-line="none"
              vertical-line="none">
            </px-vis-cursor>
          </template>
        `;
      }

      static get thresholdsTemplate() {
        return Polymer.html`
          <template is="dom-if" if="[[_showThresholds(thresholdData.*)]]" restamp>
            <px-vis-threshold
              svg="[[layer.3]]"
              complete-series-config="[[completeSeriesConfig]]"
              threshold-data="[[thresholdData]]"
              threshold-config="[[thresholdConfig]]"
              width="[[width]]"
              height="[[height]]"
              margin="[[margin]]"
              x="[[x]]"
              y="[[y]]"
              domain-changed="[[domainChanged]]"
              clip-path="[[seriesClipPath]]"
              show-threshold-box="[[showThresholdBox]]"
              language="[[language]]">
            </px-vis-threshold>
          </template>
        `;
      }

      static get referenceCurveTemplate() {
        return Polymer.html`
          <template is="dom-if" if="[[_showRef(referenceData.*)]]" restamp>
            <px-vis-reference-curve
              id="referenceCurve"
              chart-id="[[chartId]]"
              svg="[[_lineG]]"
              x="[[x]]"
              y="[[y]]"
              reverse-data="[[_isOrdinalType(yAxisType)]]"
              domain-changed="[[domainChanged]]"
              reference-config="[[referenceConfig]]"
              reference-data="[[referenceData]]"
              clip-path="[[seriesClipPath]]"
              on-_reference-config-changed="_checkReference">
            </px-vis-reference-curve>
          </template>
        `;
      }

      static get tooltipTemplate() {
        return Polymer.html`
          <template is="dom-if" if="[[showTooltip]]" restamp>
            <px-vis-tooltip
              id="tooltip"
              orientation="[[_getTooltipOrientation(xAxisType)]]"
              hover-target=[[mouseRect]]
              mouse-position="[[mousePosition]]"
              width="250"
              margin="[[margin]]"
              chart-data="[[chartData]]"
              tooltip-data="[[tooltipData]]"
              complete-series-config="[[completeSeriesConfig]]"
              x-axis-type="[[xAxisType]]"
              y-axis-type="[[yAxisType]]"
              tooltip-style="light"
              muted-series="[[mutedSeries]]"
              hide="[[!_computedShowTooltip]]"
              series-keys="[[_seriesKeys]]"
              display-x-values-only="[[_getRegisterDisplay(yAxisType)]]"
              display-y-values-only="[[_getRegisterDisplay(xAxisType)]]"
              display-ordinal-value
              icon-color="[[_registerIconColor]]">
            </px-vis-tooltip>
          </template>
        `;
      }

      static get extendBarChartTemplate() { return Polymer.html``; }


      static get properties() {
        return {
          preventWebWorkerSynchronization: {
            type: Boolean,
            value: true,
            readOnly: true
          },
          /**
          * A default configuration file. It fills in the missing parts of seriesConfig. Any options from seriesConfig can be specified in the defaultSeriesConfig and will be automatically used if not defined in the seriesConfig
          *
          * Default:
          *
          * ```
          *  {
          *     "type": "bar",
          *     "x": "x",
          *     "y": "y"
          *   }
          * ```
          */
          _defaultSeriesConfig: {
            type: Object,
            value: function() {
              return {
                x: "x",
                y: "y",
                type: "bar"
              }
            }
          },
          /**
          * Specfies what type of bar chart:
          * - `bar`
          * - `column`
          */
          chartType: {
            type: String,
            value: 'column'
          },

          _stackedChartData: {
            type: Array
          },

          /**
          * Defines where to locate the X-axis.
          * - `bottom`
          * - `top`
          *
          */
          xAxisLocation: {
            type:String,
            value:'bottom'
          },
          /**
          * Defines where to locate the Y-axis.
          * - `left`
          * - `right`
          *
          */
          yAxisLocation: {
            type: String,
            value:'left'
          },

          /**
          * DO NOT CHANGE THIS UNLESS YOU KNOW WHAT YOU ARE DOING
          *
          * Bar charts in nearly all cases should start from 0. If you have a special case and understand the ramifications, change this to false to allow it to use the `min` value from your data
          */
          startFromZero: {
            type: Boolean,
            value: true
          },

          _ordinalKey: {
            type: String,
            computed: '_getOrdKey(completeSeriesConfig.*)'
          },

          _stackedDataExtentsTrigger: {
            type: Number,
            value: 0
          },
          /**
           * Create a grouped bar chart.
           *
           * Default is to create a stacked bar chart
           * */
          grouped: {
            type: Boolean,
            value: false
          },

          /**
           * Color each group one color rather than a series across groups having the same color
           *
           * */
          colorByGroup: {
            type: Boolean,
            value: false
          },
          /**
           * An object associating group colors to your groups
           *
           * ```
           * {
           *   group1: "rgb(255,0,0)",
           *   group2: "rgb(0,255,0)",
           *   group3: "rgb(0,0,255)",
           * }
           * ```
           *
           * */
          groupColors: Object,
          _groupColors: Object,
          _registerIconColor: String,
          _lineG: Object,
          _baseline: Object,
          _groupKeys: Object,
          _lineSeriesConfig: Object,
          _hasLines: {
            type: Boolean,
            value: false
          },
          _hasThresholds: {
            type: Boolean,
            value: false
          },
          _hasReferenceCurve: {
            type: Boolean,
            value: false
          },

        };
      }

      static get observers() {
        return [
          '_returnStack(chartData.*, completeSeriesConfig.*)',
          '_setAxisTypes(chartType)',
          '_groupChanged(grouped)',
          '_setGroupColors(grouped,colorByGroup,domainChanged)',
          '_setXScale(width, margin, xAxisType)',
          '_setYScale(height, margin, yAxisType)',
          '_setDomain(_chartDataHasChanged, x, y, completeSeriesConfig, _stackedDataExtentsTrigger)',
          '_setDomain(chartExtents, _stackedDataExtentsTrigger)',
          '_updatePadding(scalePadding)',
          '_chartDataChanged(chartData.*)',
          '_calcTooltipPos(tooltipData.*)',
          '_getRegisterIconColor(tooltipData.*)',
          '_calcStackedDataExt(_stackedChartData, completeSeriesConfig, grouped)',
          '_createGroupScale(x,y, domainChanged, completeSeriesConfig, _seriesKeys, grouped)',
          '_createLineGroup(layers, domainChanged)',
          '_drawBaseline(domainChanged)',

          '_xAxisConfigChanged(xAxisConfig.*)',
          '_yAxisConfigChanged(yAxisConfig.*)',

          // dynamic loading
          '_loadBars(grouped)',
          '_loadLines(_hasLines)',
          '_loadThresholds(thresholdData)',
          '_loadReferenceCurve(referenceData)',
          '_loadTooltip(showTooltip)',
        ];
      }

      constructor() {
        super();
        this.__debouncers = {};
      }

      connectedCallback() {
        super.connectedCallback();
        this.set('numberOfLayers', 5);
        this.set('_verticalRegisterDrawingCanvasId', 'svg');
        this.set('_verticalRegisterHeightDeductions', ['toolbar']);
      }

      ready() {
        super.ready();
        this.addEventListener('iron-resize', this._onIronResize.bind(this));
      }

      _debounce(name, cb, time) {
        this.__debouncers[name] = Polymer.Debouncer.debounce(
          this.__debouncers[name],
          Polymer.Async.timeOut.after(time),
          cb.bind(this));
      }

      _onIronResize() {
        if(this.preventResize) {
          return;
        }

        this._debounce('ironresize', this._onIronResizeDebounced, this.debounceResizeTiming);
      }

      _onIronResizeDebounced() {
        //make sure we are not preventing resize in case it changed while debouncing
        if(this.preventResize) {
          return;
        }

        requestAnimationFrame(() => {
          var wrapperRect = this.$.wrapper.getBoundingClientRect(),
              registerRect = this.$.register.getBoundingClientRect(),
              toolbarRect = this.$.toolbar.getBoundingClientRect(),
              heightDeduct = 0,
              widthDeduct = 0;


          if(this.$.register.type === 'horizontal') {
            heightDeduct += registerRect.height;
          } else {
            widthDeduct += registerRect.width;
          }

          heightDeduct += toolbarRect.height;

          this.set('width', Math.max(wrapperRect.width - widthDeduct, 0));
          this.set('height', Math.max(wrapperRect.height - heightDeduct, 0));
          this._computeVerticalRegisterHeight([toolbarRect.height]);
        });
      }

      _returnStack() {
        if(this.grouped) {
          this.set('_stackedChartData', []);
          return;
        }

        if(!this.chartData ||
            !this.completeSeriesConfig) {
          return;
        }

        const axis = this.xAxisType === 'scaleBand' ? 'y' : 'x';
        const stack = Px.d3.stack();
        const barKeys = [];
        let hasLines = false;
        const lineSeries = {};

        // could use Object.values but there doesnt appear to be an official
        // shim for IE yet and value of shiming it vs just using entries ¯\_(ツ)_/¯
        Object.entries(this.completeSeriesConfig).forEach(([k,val]) => {
          if(val.type === 'bar') {
            barKeys.push(val[axis]);
          } else if(val.type === 'line') {
            hasLines = true;
            lineSeries[k] = val;
          }
        });

        stack.offset(Px.d3.stackOffsetDiverging);
        stack.keys(barKeys);
        this.set('_stackedChartData', stack(this.chartData));
        this.set('_hasLines', hasLines);
        this.set('_lineSeriesConfig', lineSeries);
      }

      _setAxisTypes(chartType) {
        if(this.domainChanged) {
          this.setProperties({
            domainChanged: 0,
            x: null,
            y: null,
            dataExtents: null
          });

        }

        if(chartType === 'bar') {
          this.setProperties({
            'xAxisType': "linear",
            'yAxisType': "scaleBand"
          });
        } else { //column
          this.setProperties({
            'xAxisType': "scaleBand",
            'yAxisType': "linear"
          });
        }

        this._setCompleteSeriesConfig();
      }

      _groupChanged() {
        this._setCompleteSeriesConfig();
      }

      _setGroupColors() {
        if(this.grouped && this.colorByGroup) {
          this._dontCalcColors = true;
          if(this.groupColors) {
            this.set('_groupColors', this.groupColors);
            return;
          }

          if(this.domainChanged) {
            const groups = this.x.domain();
            const colors = {};

            groups.forEach((group, i) => {
              colors[group] = this.seriesColorList[i];
            });

            this.set('_groupColors', colors);
          }
        } else {
          this._dontCalcColors = false;
        }
      }

      _getOrdKey() {
        if(this.hasUndefinedArguments(arguments)) {
          return;
        }

        if(this._seriesKeys && this._seriesKeys.length) {
          const k = this.xAxisType === 'scaleBand' ? 'x' : 'y';
          return this.completeSeriesConfig[this._seriesKeys[0]][k];
        } else {
          return '';
        }
      }

      _getRegisterDisplay(axisType) {
        return axisType === 'scaleBand'
      }

      _showGridlines(hideGridlines, chartType, type) {
        if(chartType === type && !hideGridlines) {
          return true;
        }

        return false;
      }

      _calcTooltipPos() {
        if(this.showTooltip && this.tooltipData && this.tooltipData.series && this.tooltipData.series.length && this.tooltipData.series[0].coord) {
          if(!this._svgClientRect) {
            this._getImmediateSizing();
          }

          //calc the screen positions for the tooltip
          let screenX = this._svgClientRect.left + this._winX + this.margin.left;
          let screenY = this.margin.top + this._svgClientRect.top + this._winY;

          if(this.xAxisType === 'scaleBand') {
            screenX += this.x.bandwidth()/2 + this.tooltipData.series[0]['coord'][0];
            screenY += this.grouped ?
                        this._getLargestCoord(1, 'min') :
                        this.y(this._getSummedVal.bind(this)('x'));

          } else {
            screenY += this.y.bandwidth()/2 + this.tooltipData.series[0]['coord'][1];
            screenX += this.grouped ?
                        this._getLargestCoord(0, 'max') :
                        this.x(this._getSummedVal.bind(this)('y'));

          }

          this.set('mousePosition', [screenX, screenY]);
        }
      }

      _getRegisterIconColor() {
        if(this.grouped && this.colorByGroup) {
          const set = this._getOrdSet();

          if(set) {
            this.set('_registerIconColor', this._groupColors[set]);
          } else {
            this.set('_registerIconColor', undefined);
          }
        }
      }

      _getLargestCoord(index, type) {
        return Px.d3[type](this.tooltipData.series, (d) => { return d.coord[index]; });
      }

      _getSummedVal(axis) {
        let index = Px.d3.bisectLeft(this[axis].domain(), this.tooltipData.ordinalSet);

        // periodic d3 overflow bug? When on the first item (so left should = -1), sets index to arr.length
        if(index === this[axis].domain().length) {
          index -= 1;
        }

        return Px.d3.max(this._stackedChartData, (d) => { return Math.max(d[index][0],d[index][1]); });
      }

      _getOrdSet() {
        if(this.tooltipData && this.tooltipData.ordinalSet) {
          return this.tooltipData.ordinalSet;
        }

        return '';
      }

      _calcStackedDataExt() {
        if(this.grouped) {
          this.set('_stackedDataExtentsTrigger', this._stackedDataExtentsTrigger += 1);
          return;
        }

        if(this.completeSeriesConfig && this._doesObjHaveValues(this._stackedChartData)) {
          // find the stacked values (which are generally bigger than raw chartData)
          const min = Px.d3.min(this._stackedChartData, (dataset) => {
            return Px.d3.min(dataset, (d) => { return Math.min(d[0],d[1]); });
          });
          const max = Px.d3.max(this._stackedChartData, (dataset) => {
            return Px.d3.max(dataset, (d) => { return d[1]; });
          });

          const exts = [min, max];
          const valScale = this._getValueKey();

          // now check our line series to see if they are bigger/smaller than stacks
          Object.entries(this.completeSeriesConfig).forEach(([k,val]) => {
            if(val.type === 'line') {
              const ext = Px.d3.extent(this.chartData, (d) => {
                return d[val[valScale]];
              });

              exts[0] = Math.min(ext[0],exts[0]);
              exts[1] = Math.max(ext[1],exts[1]);
            }
          });

          if(this.xAxisType === 'scaleBand') {
            this.dataExtents = {
              "x": this.dataExtents.x,
              "y": exts
            };
          } else {
            this.dataExtents = {
              "x": exts,
              "y": this.dataExtents.y
            };
          }

          this.set('_stackedDataExtentsTrigger', this._stackedDataExtentsTrigger += 1);
        }
      }

      _createGroupScale() {
        if(!this.grouped ||
            !this.x ||
            !this.y ||
            !this.completeSeriesConfig ||
            this._seriesKeys.length === 0 ||
            !this.domainChanged) {
          return;
        }

        const ordScale = this.xAxisType === 'scaleBand' ? 'x' : 'y';
        const valScale = this._getValueKey();
        const domain = [];
        const keys = [];
        let hasLines = false;
        const lineSeries = {};

        Object.entries(this.completeSeriesConfig).forEach(([k,val]) => {
          if(val.type === 'bar') {
            domain.push(val[valScale]);
            keys.push(k);
          } else if(val.type === 'line') {
            hasLines = true;
            lineSeries[k] = val;
          }
        });

        const scale = Px.d3.scaleBand()
          .padding(0.05)
          .rangeRound([0, this[ordScale].bandwidth()])
          .domain(domain);

        this.set('_groupKeys', keys);
        this.set('_groupScale', scale);
        this.set('_hasLines', hasLines);
        this.set('_lineSeriesConfig', lineSeries);
      }

      _createLineGroup() {
        if(!this.layer || this._isD3Empty(this.layer[3]) || !this.domainChanged) {
          return;
        }

        var g;

        if(this._isD3Empty(this._lineG)) {
          g = this.layer[3].append('g')
            .attr('class', 'lines');

          this.set('_lineG', g);
        }

        if(this._isOrdinalType(this.x._scaleType)) {
          this._lineG.attr('transform', 'translate(' + this.x.bandwidth()/2 + ',0)');

        } else if(this._isOrdinalType(this.y._scaleType)) {
          this._lineG.attr('transform', 'translate(0,' + this.y.bandwidth()/2 + ')');
        }

      }

      _drawBaseline() {
        if(!this.domainChanged) {
          return;
        }

        const valScale = this._getValueKey();

        if(this[valScale].domain()[0] < 0) {
          let x1, x2,
              y1, y2;

          if(this.xAxisType === 'scaleBand') {
            x1 = this.x.range()[0];
            x2 = this.x.range()[1];
            y1 = this.y(0);
            y2 = this.y(0);

          } else {
            x1 = this.x(0);
            x2 = this.x(0);
            y1 = this.y.range()[0];
            y2 = this.y.range()[1];

          }

          if(!this._baseline) {
            this._baseline = this.layer[3]
              .append('line')
          }

          this._baseline
            .attr('x1', x1)
            .attr('x2', x2)
            .attr('y1', y1)
            .attr('y2', y2)
            .attr('stroke', this._checkThemeVariable("--px-vis-axis-color", 'black'));

        } else {
          if(this._baseline) {
            if(this._baseline.remove) {
              this._baseline.remove();
            }
            this._baseline = null;
          }
        }
      }

      _getValueKey() {
        return this.xAxisType === 'scaleBand' ? 'y' : 'x'
      }

      _xAxisConfigChanged(conf) {
        if(this.hasUndefinedArguments(arguments)) {
          return;
        }

        this._applyConfigToElement(this.xAxisConfig, this.$.xAxis);
      }

      _yAxisConfigChanged(conf) {
        if(this.hasUndefinedArguments(arguments)) {
          return;
        }

        this._applyConfigToElement(this.yAxisConfig, this.$.yAxis);
      }

      _getTooltipOrientation(xAxisType) {
        return xAxisType === 'scaleBand' ? 'top' : 'right';
      }

      _checkReference(evt) {
        let target = evt.target;
        this._debounce('_checkReference', () => {

          if(!this.referenceData || !target || !target._referenceConfig) {
            return;
          }

          Object.entries(target._referenceConfig).forEach(([k,val]) => {
            let search = true,
                i = 0;

            while(search) {
              let xInvalid = true,
                  yInvalid = true;

              if(this._isValidData(this.referenceData[i][val.x]) && this._isValidData(this.x(this.referenceData[i][val.x]))) {
                xInvalid = false;
              }
              if(this._isValidData(this.referenceData[i][val.y]) && this._isValidData(this.y(this.referenceData[i][val.y]))) {
                yInvalid = false;
              }

              search = xInvalid || yInvalid;
              i += 1;

              if(i === this.referenceData.length) {
                console.warn('Something is wrong with your referenceConfig / referenceData. Did you flip the x and y?');
                search = false;
              }
            }
          });
        }, 100);
      }

      _returnLineSeriesKeys() {
        return Object.keys(this._lineSeriesConfig);
      }

      _showThresholds() {
        return this.thresholdData && this.thresholdData.length ? true : false;
      }

      _showRef() {
        return this.referenceData && this.referenceData.length ? true : false;
      }

      _loadGroupedBars() {
        if(this._groupedBarLoaded) {
          return;
        }

        this.importHref(this.resolveUrl('../px-vis/px-vis-bar-grouped-svg.html'), () => { this._groupedBarLoaded = true; }, null, true);
      }

      _loadStackedBars() {
        if(this._stackedBarLoaded) {
          return;
        }

        this.importHref(this.resolveUrl('../px-vis/px-vis-bar-svg.html'), () => { this._stackedBarLoaded = true; }, null, true);
      }

      _loadBars() {
        if(this.grouped) {
          this._loadGroupedBars();
        } else {
          this._loadStackedBars();
        }
      }

      _loadLines() {
        if(!this.hasLines || this._linesLoaded) {
          return;
        }

        this.importHref(this.resolveUrl('../px-vis/px-vis-line-svg.html'), () => { this._linesLoaded = true; }, null, true);
        this.importHref(this.resolveUrl('../px-vis/px-vis-cursor.html'), null, null, true);

      }

      _loadThresholds() {
        if(!this.thresholdData || !this.thresholdData.length || this._thresholdsImported) {
          return;
        }

        this.importHref(this.resolveUrl('../px-vis/px-vis-threshold.html'), () => { this._thresholdsImported = true; }, null, true);

      }

      _loadReferenceCurve() {
        if(!this.referenceData || !this.referenceData.length || this._referenceCurveImported) {
          return;
        }

        this.importHref(this.resolveUrl('../px-vis/px-vis-reference-curve.html'), () => { this._referenceCurveImported = true; }, null, true);

      }

      _loadTooltip() {
        if(!this.showTooltip || this._tooltipImported) {
          return;
        }

        this.importHref(this.resolveUrl('../px-vis/px-vis-tooltip.html'), () => { this._tooltipImported = true; }, null, true);
      }
    }

    window.customElements.define(PxVisBarChart.is, PxVisBarChart);
    window.PxVisBarChart = PxVisBarChart;
  })();

  </script>
</dom-module>
